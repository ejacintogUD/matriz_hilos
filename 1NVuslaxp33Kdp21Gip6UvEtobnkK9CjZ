from machine import Pin
from time import sleep, sleep_us
import _thread

# Definición de pines
DS = Pin(1, Pin.OUT)    # Datos seriales a correr
SHCP = Pin(4, Pin.OUT)  # Reloj del registro de corrimiento
STCP_C = Pin(5, Pin.OUT)  # Reloj del Latch del registro Columnas
STCP_R = Pin(6, Pin.OUT)  # Reloj del Latch del registro Filas
led = Pin(2, Pin.OUT)   # LED de verificacion


data_c = [0x7F, 0xBF, 0xCF, 0xEF, 0xF7, 0xFB, 0xFC, 0xFE]

mensaje_hex =  [
    # U (nueva forma, espejada)
    0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x36, 0x1C,
    0x00,  # Espacio
    # N (mayúscula, espejada, 8 posiciones)
    0x63, 0x73, 0x7B, 0x6F, 0x67, 0x63, 0x63, 0x63,
    0x00,  # Espacio
    # I (espejado)
    0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C,
    0x00,  # Espacio
    # V (espejado)
    0x66, 0x66, 0x66, 0x66, 0x66, 0x24, 0x24, 0x1C,
    0x00,  # Espacio
    # E (espejado)
    0x7F, 0x66, 0x03, 0x03, 0x1F, 0x03, 0x03, 0x66,
    0x00,  # Espacio
    # R (espejado)
    0x3F, 0x63, 0x63, 0x63, 0x3F, 0x33, 0x33, 0x63,
    0x00,  # Espacio
    # S (espejado)
    0x3C, 0x66, 0x43, 0x03, 0x1E, 0x30, 0x43, 0x66,
    0x00,  # Espacio
    # I (espejado)
    0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C,
    0x00,  # Espacio
    # D (espejado)
    0x1F, 0x33, 0x63, 0x63, 0x63, 0x63, 0x33, 0x1F,
    0x00,  # Espacio
    # A (nueva forma, espejada)
    0x18, 0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66,
    0x00,  # Espacio
    # D (espejado)
    0x1F, 0x33, 0x63, 0x63, 0x63, 0x63, 0x33, 0x1F,
    0x00,  # Espacio
    # D (espejado)
    0x1F, 0x33, 0x63, 0x63, 0x63, 0x63, 0x33, 0x1F,
    0x00,  # Espacio
    # I (espejado)
    0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C,
    0x00,  # Espacio
    # S (espejado)
    0x3C, 0x66, 0x43, 0x03, 0x1E, 0x30, 0x43, 0x66,
    0x00,  # Espacio
    # T (espejado)
    0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x00,  # Espacio
    # R (espejado)
    0x3F, 0x63, 0x63, 0x63, 0x3F, 0x33, 0x33, 0x63,
    0x00,  # Espacio
    # I (espejado)
    0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C,
    0x00,  # Espacio
    # T (espejado)
    0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x00,  # Espacio
    # A (nueva forma, espejada)
    0x18, 0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66,
    0x00,  # Espacio
    # L (espejado)
    0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x66, 0x7F,
    0x00,  # Espacio
]

i =0
j = 0
lock = _thread.allocate_lock()

# Funciones
def shift_data(data):
    for i in range(8):
        DS.value(data & 0x01)
        SHCP.value(0)
        sleep_us(1)  # 1 microsegundo
        SHCP.value(1)
        sleep_us(1)  # 1 microsegundo
        data >>= 1

def load_data_c(data):
    STCP_C.value(0)
    shift_data(data)
    STCP_C.value(1)

def load_data_r(data):
    STCP_R.value(0)
    shift_data(data)
    STCP_R.value(1)
    

def send_data(data_c,data_r):
    load_data_c(data_c)
    load_data_r(data_r)
       
      
def correr_men():
    global j
    while True:
        with lock: #Modifico la  variable J
            j = j + 1
            if (j == len(mensaje_hex)-8):
                j=0 
        sleep(0.2)

def visualizar():
    global j
    global i
    while True:
        with lock: #utilizo de la variable J
            i = i + 1
            if (i == 8):
                i=0    
            send_data(data_c[i],mensaje_hex[i+j])
        sleep(0.00277)
  
    
DS.value(0)
SHCP.value(0)
STCP_R.value(0)
STCP_C.value(0)
sleep(1)  # 1 segundo

_thread.start_new_thread(correr_men, ())
_thread.start_new_thread(visualizar, ())


while True:
    led.value(not led.value())  # Alternar el estado del LED
    sleep(1)

    
